---
title: "analysis"
author: "Zakari L. Billo"
output: pdf_document
---

```{r include=false}
library(tidyverse)
library(glmnet)
library(pcalg)
library(foreach)
library(doParallel)
library(reshape2)
library(graph)
library(stats)
```

## Load clean datasets

```{r}
X_filtered <- read_csv("data/X_filtered.csv")
X_filtered <- as.data.frame(X_filtered)

X_asthma <- read_csv("data/X_asthma.csv")
X_asthma <- as.data.frame(X_asthma)

X_normal <- read_csv("data/X_normal.csv")
X_normal <- as.data.frame(X_normal)
```

Run Lasso for the "DOCK9" neighborhood and Compare lamda options for optimal selection

```{r}
library(glmnet)
library(doParallel)

# 1. Setup Data: Target DOCK9
# Yes, this correctly targets DOCK9. By setting y = DOCK9, you are asking
# the Lasso to find which other genes (x) are most predictive of DOCK9.
y <- as.numeric(X_filtered[, "DOCK9"])
x <- as.matrix(X_filtered[, setdiff(colnames(X_filtered), "DOCK9")])

# 2. Generate a fixed Lambda Sequence
# We MUST do this once on the full data so every bootstrap iteration 
# uses the exact same grid. Otherwise, the matrices won't match up.
full_fit <- glmnet(x, y, alpha = 1) 
lambda_seq <- full_fit$lambda 

n_stab_boot <- 10000 
n_cores <- detectCores() - 1
cl <- makeCluster(n_cores)
registerDoParallel(cl)

# 3. Subsampling function (Alpha fixed to 1)
run_lasso_sub <- function(x, y, lambdas) {
  # Subsample 50% without replacement
  sub_idx <- sample(1:nrow(x), floor(nrow(x))/2, replace = FALSE)
  
  # Run glmnet with the FIXED lambda sequence and alpha = 1
  fit <- glmnet(x[sub_idx,], y[sub_idx], alpha = 1, lambda = lambdas)
  
  # Return binary matrix (1 if selected, 0 if not)
  coefs <- coef(fit, s = lambdas)
  return(as.matrix(coefs[-1, ] != 0) * 1) 
}

# Export standard lambda_seq to cluster
clusterExport(cl, c("x", "y", "lambda_seq", "run_lasso_sub"))
clusterEvalQ(cl, library(glmnet))

# 4. Bootstrap
message(paste("Running", n_stab_boot, "stability bootstraps..."))
stab_list <- foreach(i = 1:n_stab_boot) %dopar% {
  run_lasso_sub(x, y, lambda_seq)
}
stopCluster(cl)

# 5. Stability probabilities
prob_matrix <- Reduce("+", stab_list) / n_stab_boot
colnames(prob_matrix) <- paste0("L", 1:length(lambda_seq))

# Optimal lambda
cv_check <- cv.glmnet(x, y, alpha = 1, lambda = lambda_seq)
target_lambda_idx <- which(lambda_seq == cv_check$lambda.1se)

# If exact match fails due to float precision, use nearest index:
if(length(target_lambda_idx) == 0) {
    target_lambda_idx <- which.min(abs(lambda_seq - cv_check$lambda.1se))
}

# Stability scores at that Lambda
gene_stability_scores <- prob_matrix[, target_lambda_idx]

# Create and sort df
stability_df <- data.frame(
  Gene = rownames(prob_matrix), # Use rownames from the matrix
  Stability_Prob = as.numeric(gene_stability_scores)
)

# Sort descending
stability_df <- stability_df[order(-stability_df$Stability_Prob), ]

# Top genes
top_genes <- head(stability_df$Gene, 100)

# Include DOCK9 at the top of the list
final_genes <- unique(c("DOCK9", top_genes))

# Keep top 100 (Including DOCK9)
if(length(final_genes) > 100) {
  final_genes <- final_genes[1:100]
}

# Save 
X_asthma_stable <- X_asthma[, final_genes]
write.csv(X_asthma_stable, "data/X_asthma_stable.csv", row.names = FALSE)

X_normal_stable <- X_normal[, final_genes]
write.csv(X_normal_stable, "data/X_normal_stable.csv", row.names = FALSE)
```

Plot PAGs 

```{r}
analyze_pag_sensitivity <- function(data, title = NULL, file_name = NULL) {
  
  # Filename setup
  data_arg_name <- deparse(substitute(data)) 
  
  if (is.null(file_name)) {
    clean_title <- gsub("[^[:alnum:]]", "_", title)
    file_name <- paste0(clean_title, ".pdf")
  }
  
  # Define alphas
  alphas <- c(0.01, 0.05, 0.10)
  
  # Initialize results df
  results_df <- data.frame(Alpha = numeric(), 
                            Edge_Count = integer(), 
                            Time_Sec = numeric())
  
  # suffStat
  suffStat <- list(C = cor(data, use = "pairwise.complete.obs"), n = nrow(data))
  
  pdf(file_name, width = 10, height = 10)
  
  for (alpha in alphas) {
    
    message(paste("Running FCI for Alpha:", alpha, "..."))
    
    # system.time
    pag.est <- NULL
    
    timer <- system.time({
      pag.est <- fci(suffStat, indepTest = gaussCItest, alpha = alpha, 
                     labels = colnames(data), verbose = FALSE, m.max = 4)
    })
    
    # Extract elapsed time
    duration <- timer["elapsed"]
    
    # Count Edges
    amat <- pag.est@amat
    current_edges <- sum(amat[upper.tri(amat)] != 0)
    
    # Store Results
    results_df <- rbind(results_df, data.frame(Alpha = alpha, 
                                                 Edge_Count = current_edges, 
                                                 Time_Sec = as.numeric(duration)))
    
    # Plot PAG
    plot(pag.est)
    
    # Title
    title_text <- paste0(title, 
                         "\nalpha: ", alpha, 
                         "   edges: ", current_edges, 
                         "   time: ", round(duration, 3), "s")
    
    title(main = title_text, col.main = "blue", cex.main = 1.5)
  }
  
  dev.off()
  
  return(results_df)
}

results_asthma <- analyze_pag_sensitivity(X_asthma_stable,
                                          file_name = "Asthma_PAG_Analysis.pdf")

results_normal <- analyze_pag_sensitivity(X_normal_stable,
                                          file_name = "Normal_PAG_Analysis.pdf")

print(results_asthma)
print(results_normal)

# Visualize runtime
plot(results_asthma$Alpha, results_asthma$Time_Sec, 
     type = "b", pch = 19, col = "red",
     main = "Computation Time by Alpha",
     xlab = "Alpha", ylab = "Time (seconds)")

plot(results_normal$Alpha, results_normal$Time_Sec, 
     type = "b", pch = 19, col = "red",
     main = "Computation Time by Alpha",
     xlab = "Alpha", ylab = "Time (seconds)")
```

Go with alpha = 0.05, use LV-IDA to see the causal effect of DOCK9 on other genes

```{r}
source("lv-ida/lvida.R") 
source("lv-ida/iscyclic.R")

library(pcalg)
# Ensure these files are loaded
if(!exists("lvida")) source("lv-ida/lvida.R") 
if(!exists("is.cyclic")) source("lv-ida/iscyclic.R")

estimate_downstream_effects_no_plot <- function(data, cause_var, n_boots = 100, file_name = NULL) {
  
  # 1. Setup
  alphas <- c(0.05)
  cause_idx <- which(colnames(data) == cause_var)
  
  if (length(cause_idx) == 0) stop("Cause variable not found in data.")
  
  potential_targets <- colnames(data)[-cause_idx]
  n_targets <- length(potential_targets)
  n_obs <- nrow(data)
  
  final_summary <- data.frame()
  
  # 2. File Name Setup (CSV Only)
  clean_cause <- gsub("[^[:alnum:]]", "_", cause_var)
  
  if (is.null(file_name)) {
    csv_name <- paste0("Downstream_Effects_", clean_cause, ".csv")
  } else {
    # Ensure it ends in .csv
    csv_name <- ifelse(grepl("\\.csv$", file_name), file_name, paste0(file_name, ".csv"))
  }
  
  for (alpha in alphas) {
    message(paste("\n=== Processing Alpha =", alpha, "==="))
    
    # Storage matrices
    boot_min_effects <- matrix(NA, nrow = n_targets, ncol = n_boots)
    boot_max_effects <- matrix(NA, nrow = n_targets, ncol = n_boots)
    
    # 3. Bootstrap Loop
    for (b in 1:n_boots) {
      if (b %% 10 == 0) message(paste("   Bootstrap", b, "/", n_boots))
      
      # Resample
      boot_indices <- sample(1:n_obs, n_obs, replace = TRUE)
      boot_data <- data[boot_indices, ]
      
      # Stats
      suffStat <- list(C = cor(boot_data, use = "pairwise.complete.obs"), n = n_obs)
      mcov <- cov(boot_data, use = "pairwise.complete.obs")
      
      # Run FCI
      pag.est <- tryCatch({
        fci(suffStat, indepTest = gaussCItest, alpha = alpha, 
            labels = colnames(data), verbose = FALSE, m.max = 4)
      }, error = function(e) return(NULL))
      
      if (is.null(pag.est)) next
      
      amat <- pag.est@amat
      
      # Check Targets
      for (i in seq_along(potential_targets)) {
        target_name <- potential_targets[i]
        target_idx <- which(colnames(data) == target_name)
        
        # Optimization: Only run IDA if target is a possible descendant
        is_possible_descendant <- target_idx %in% pcalg::possibleDe(amat, cause_idx)
        
        if (!is_possible_descendant) {
          boot_min_effects[i, b] <- 0
          boot_max_effects[i, b] <- 0
        } else {
          tryCatch({
            if (exists("lvida", mode = "function")) {
               effs <- lvida(cause_idx, target_idx, mcov, amat)
            } else {
               effs <- lvIda(cause_idx, target_idx, mcov, amat)
            }
            
            if (!all(is.na(effs))) {
              boot_min_effects[i, b] <- min(abs(effs))
              boot_max_effects[i, b] <- max(abs(effs))
            } else {
              boot_min_effects[i, b] <- 0
              boot_max_effects[i, b] <- 0
            }
          }, error = function(e) {
             boot_min_effects[i, b] <- NA
             boot_max_effects[i, b] <- NA
          })
        }
      }
    } 
    
    # 4. Summarize Results
    alpha_summary <- data.frame(
      Target_Gene = potential_targets,
      Alpha = alpha,
      Stability_Pct = rowMeans(boot_max_effects > 0, na.rm = TRUE) * 100,
      Median_Min_Effect = apply(boot_min_effects, 1, function(x) median(x[x > 0], na.rm = TRUE)),
      Median_Max_Effect = apply(boot_max_effects, 1, function(x) median(x[x > 0], na.rm = TRUE))
    )
    
    alpha_summary[is.na(alpha_summary)] <- 0
    final_summary <- rbind(final_summary, alpha_summary)
  } 
  
  # 5. Save CSV
  write.csv(final_summary, csv_name, row.names = FALSE)
  message(paste("Saved downstream effects summary to:", csv_name))
  
  return(final_summary)
}


results_asthma <- estimate_downstream_effects_no_plot(X_asthma_stable, "DOCK9", n_boots = 100, file_name = "Asthma_DOCK9.csv")
results_normal <- estimate_downstream_effects_no_plot(X_normal_stable, "DOCK9", n_boots = 100, file_name = "Normal_DOCK9.csv")


```

