---
title: "EDA_zlb"
author: "Zakari L. Billo"
date: "2025-09-21"
output: pdf_document
---

# package setup

```{r setup, message=FALSE, warning=FALSE}
library(tidyverse)
library(pcalg)
library(ggplot2)
library(reshape2)
library(GeneralisedCovarianceMeasure)
library(future)
library(future.apply)
library(BiocVersion)
library(Rgraphviz)
library(gridExtra)
library(corrplot)
library(DiagrammeR)
library(DiagrammeRsvg) 
library(htmlwidgets) 
library(webshot)  
```

## retrieve data ##

```{r retrieve data, include=FALSE}
## This file is what allows you to get data from our MySQL server
source("/home/rstudio/getDat function_RONIN.R")

## Specify the list of variables you want
vars1 <- c("age_last", "kidney_dis", "diabetes", "sex", 
            "il_1b", "il1_ra", "il6", "il8", "il10", "il12", "il15", "il18_plasma",
            "sgp130", "il6_sr_e", "ifn_g", "tgf_b1", "tnf_a_m", "trail", "stnf_ri",
            "stnf_rii","mcp", "mip", "crp")
            
## Get the data from the MySQL database
## best_tranf = T means the data will be log transformed as appropriate

dat <- getDat(base = "inchianti", varlist = vars1, 
              best_transf = F) #set to false to do your own transformations

## This data contains measurements for individuals at multiple visits.  
## We may want to restrict this to the first visit to avoid 
## repeated measures correlation

dat <- dat[dat$visit == 0,]

## extract stratified biomarker data
## remove all NA values. leave 0s 

male_df <- dat |> filter(sex == "M") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

female_df <- dat |> filter(sex == "F") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

kidney_yes_df <- dat |> filter(kidney_dis == "1.0") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

kidney_yes_maybe_df <- dat |> filter(kidney_dis == "0.5" | kidney_dis == "1.0") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

kidney_no_df <- dat |> filter(kidney_dis =="0.0") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

diabetes_yes_df <- dat |> filter(diabetes == "1.0") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

diabetes_yes_maybe_df <- dat |> filter(diabetes == "0.5" | diabetes == "1.0") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

diabetes_no_df <- dat |> filter(diabetes == "0.0") |>
  select(vars1[-c(1, 2, 3, 4)]) |> drop_na()

## summary
summary(dat)

summary <- capture.output(summary(dat))

## Write the captured output to a text file
writeLines(summary, "summary_report.txt")


# Step 1: Get the total number of observations per variable
#total_obs <- dat %>%
#  pivot_longer(
#    cols = c(il8, mip, ifn_g),
#    names_to = "variable",
#    values_to = "value"
#  ) %>%
#  group_by(variable) %>%
#  summarise(total_n = n())

# Step 2: Get the counts for "0", ".", and NA
#counts_table <- dat %>%
#  pivot_longer(
#    cols = c(il8, mip, ifn_g),
#    names_to = "variable",
#    values_to = "value"
#  ) %>%
#  filter(value %in% c("0", ".") | is.na(value)) %>%
#  count(variable, value, name = "count")

# Step 3: Join the tables and calculate percentages
#final_table <- counts_table %>%
#  left_join(total_obs, by = "variable") %>%
#  mutate(percentage = round((count / total_n) * 100, 2)) %>%
#  select(variable, value, count, percentage)

# Convert the data frame to a graphical table object
#table_plot <- tableGrob(final_table)

# Save the graphical table as a PNG file
#ggsave("final_table.png", table_plot, dpi = 300)
```

now log transform the data:

```{r log transform}
# log_data function
log_data <- function(data) {
  data |> 
    mutate(
      across(everything(), ~ .x + 1)
    ) |>
    mutate(
      across(everything(),log)
    )
}

male_df <- male_df |> log_data()
female_df <- female_df |> log_data()
kidney_no_df <- kidney_no_df |> log_data()
kidney_yes_df <- kidney_yes_df |> log_data()
kidney_yes_maybe_df <- kidney_yes_maybe_df |> log_data()
diabetes_no_df <- diabetes_no_df |> log_data()
diabetes_yes_df <- diabetes_yes_df |> log_data()
diabetes_yes_maybe_df <- diabetes_yes_maybe_df |> log_data()
```

## pc alg, bootstrap on logged data (no variables removed)

```{r}
cpdag_plot <- function(data, alpha = 0.05, title = NULL, file_name = NULL) {
  
  # title setup
  data_arg_name <- deparse(substitute(data)) 
  if (is.null(title)) {
    clean_name <- if(data_arg_name == ".") "Data" else data_arg_name
    title <- paste("Estimated CPDAG:", clean_name)
  }
  
  # filename setup
  if (is.null(file_name)) {
    clean_title <- gsub("[^[:alnum:]]", "_", title)
    file_name <- paste0(clean_title, ".pdf")
  }

  # run PC
  suffStat <- list(C = cor(data), n = nrow(data))
  cpdag.est <- pc(suffStat, indepTest = gaussCItest, alpha = alpha, labels = colnames(data))
  
  # save plot
  pdf(file_name, width = 10, height = 10)
  plot(cpdag.est, main = title)
  dev.off()
  
}

male_df |> cpdag_plot(title = "Males")
female_df |> cpdag_plot(title = "Females")
kidney_no_df |> cpdag_plot(title = "No Kidney Disease")
kidney_yes_df |> cpdag_plot(title = "Confirmed Kidney Disease")
kidney_yes_maybe_df |> cpdag_plot(title = "Confirmed or Possible Kidney Disease")
diabetes_no_df |> cpdag_plot(title = "No Diabetes")
diabetes_yes_df |> cpdag_plot(title = "Confirmed Diabetes")
diabetes_yes_maybe_df |> cpdag_plot(title = "Confirmed or Possible Diabetes")
```

## bootstrapped skeleton function

```{r bootstrap_skeleton_function}
### function for bootstrap and skeleton
bootstrap_skeleton <- function(data,bootstrap_num=500,alpha){
   ### initialize matrix for edge counts
  num_vars <- ncol(data)
  edge_matrix <- matrix(0, num_vars, num_vars)
  colnames(edge_matrix) <- colnames(data)
  rownames(edge_matrix) <- colnames(data)
  
  for (i in 1:bootstrap_num) {
    ### bootstrap through data
    indices <- sample(1:nrow(data),replace = TRUE)
    data_boot <- data[indices,]
    
    ### run skeleton on bootstrapped sample
    suffStat <- list(C = cor(data_boot, use = "pairwise.complete.obs"),
                     n = nrow(data_boot))
    
    skeleton_fit <- skeleton(suffStat, 
                             indepTest = gaussCItest,
                             alpha = alpha,
                             labels = colnames(data_boot))
    
    ### get adjacency matrix
    adj_matrix <- as(skeleton_fit,"matrix")
    
       ### Add a check to ensure the matrix is not empty
    if (nrow(adj_matrix) > 0) {
      ### add the result to edge_matrix
      edge_matrix <- edge_matrix + adj_matrix
    }
  }
  
  edge_percentage_matrix <- edge_matrix/bootstrap_num*100
  
  return(edge_percentage_matrix)
}
```

## edge percentage extraction function

```{r edges_percentage_extraction_function}
edge_melt <- function(adj_matrix){
  ### get upper triangle of the matrix (excluding diagonal)
  diag_adj_matrix <- adj_matrix
  diag_adj_matrix[lower.tri(diag_adj_matrix, diag = TRUE)] <- NA
  
  ### melt the matrix into long format and arrange it by value
  melted_adj_data <- melt(diag_adj_matrix, na.rm = TRUE)|>
    arrange(desc(value))
  
  return(melted_adj_data)
  }
```

## adjacency percentage visualization function

```{r adjacency_percentage_visualization_function}
### visualize the adjacency percentage matrix
adj_visualization <- function(adj_matrix, alpha){
  ### melt correlation matrix
  adj_melted <- melt(adj_matrix)
  
  ### reverse factor level in Var2 in melted data
  adj_melted$Var2 <- factor(adj_melted$Var2, levels = rev(levels(factor(adj_melted$Var2))))
  
  ### name plot title
  title = paste("Heatmap of adjacency percentage with alpha",alpha)
  
  ### using ggplot to get heatmap
  ggplot(adj_melted, aes(Var1, Var2, fill = value)) +
    geom_tile() +
    scale_fill_gradient2(low = "white", 
                         high = "red",
                         limit = c(0,100), 
                         space = "Lab") +
    scale_x_discrete(position = "top") + 
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 0, vjust = 0),
          plot.title = element_text(hjust = 0.5, face = "bold", size = 14),) +
    labs(title = title, x = "", y = "")+
    coord_fixed()
}
```

## bootstrap outcome at alpha = 0.05

```{r bootstrap}
multi_boot_cpdag <- function(data, alphas = c(0.01, 0.05, 0.10), threshold = 75, seed = 1, output_dir = ".") {
  
  # get data name
  data_name <- deparse(substitute(data))
  if (data_name == ".") data_name <- "data" 
  clean_name <- gsub("[^[:alnum:]]", "_", data_name)
  
  # initialize list to store results for each alpha
  all_results <- list()
  
  # Loop through each alpha
  for (a in alphas) {
    set.seed(seed) # reset seed across alphas
    
    # run bootstrap 
    adj_matrix <- bootstrap_skeleton(data, alpha = a)
    melted_adj_data <- edge_melt(adj_matrix)
    filtered_edges <- melted_adj_data[which(melted_adj_data$value > threshold), ]
    
    # define filenames
    file_suffix <- paste0(clean_name, "_alpha", a)
    table_filename <- file.path(output_dir, paste0("edges_g", threshold, "_", file_suffix, ".png"))
    pdf_filename   <- file.path(output_dir, paste0("adj_map_", file_suffix, ".pdf"))
    
    # table grob for png
    if (nrow(filtered_edges) > 0) {
      table_plot <- tableGrob(filtered_edges, rows = NULL)
      ggsave(table_filename, plot = table_plot, dpi = 300, width = 6, height = 4)
    } 
    
    # save adj matrix heatmap pdf
    pdf(pdf_filename, width = 10, height = 10)
    hm_plot <- adj_visualization(adj_matrix, alpha = a)
    print(hm_plot)
    dev.off()
    
    # store result in list
    all_results[[paste0("alpha_", a)]] <- filtered_edges
  }
  
  return(all_results)
}

multi_boot_cpdag(male_df)
multi_boot_cpdag(female_df)
multi_boot_cpdag(diabetes_no_df)
multi_boot_cpdag(diabetes_yes_df)
multi_boot_cpdag(diabetes_yes_maybe_df)
multi_boot_cpdag(kidney_no_df)
multi_boot_cpdag(kidney_yes_df)
multi_boot_cpdag(kidney_yes_maybe_df)
```
now repeat the above with fci

```{r}
pag_plot <- function(data, alpha = 0.05, title = NULL, file_name = NULL) {
  
  # title setup
  data_arg_name <- deparse(substitute(data)) 
  if (is.null(title)) {
    clean_name <- if(data_arg_name == ".") "Data" else data_arg_name
    title <- paste("Estimated PAG:", clean_name)
  }
  
  # filename setup
  if (is.null(file_name)) {
    clean_title <- gsub("[^[:alnum:]]", "_", title)
    file_name <- paste0(clean_title, ".pdf")
  }

  # run FCI
  suffStat <- list(C = cor(data), n = nrow(data))
  pag.est <- fci(suffStat, indepTest = gaussCItest, alpha = alpha, labels = colnames(data))
  
  # save plot
  pdf(file_name, width = 10, height = 10)
  plot(pag.est, main = title)
  dev.off()
  
}

male_df |> pag_plot(title = "Males")
female_df |> pag_plot(title = "Females")
kidney_no_df |> pag_plot(title = "No Kidney Disease")
kidney_yes_df |> pag_plot(title = "Confirmed Kidney Disease")
kidney_yes_maybe_df |> pag_plot(title = "Confirmed or Possible Kidney Disease")
diabetes_no_df |> pag_plot(title = "No Diabetes")
diabetes_yes_df |> pag_plot(title = "Confirmed Diabetes")
diabetes_yes_maybe_df |> pag_plot(title = "Confirmed or Possible Diabetes")
```
##### bootstrap
```{r bootstrap_skeleton_function_non_parelle}
bootstrap_pag_edges <- function(data, bootstrap_num, alpha) {
  
  n_nodes <- ncol(data)
  node_names <- colnames(data)
  
  ### initialize matrices for edge counts
  skeleton_matrix <- matrix(0, n_nodes, n_nodes, dimnames = list(node_names, node_names))
  ancestor_matrix <- matrix(0, n_nodes, n_nodes, dimnames = list(node_names, node_names))
  confounded_matrix <- matrix(0, n_nodes, n_nodes, dimnames = list(node_names, node_names))
  circle_matrix <- matrix(0, n_nodes, n_nodes, dimnames = list(node_names, node_names))
  
  for (i in 1:bootstrap_num) {
    if (i %% 1 == 0) {
      message("bootstrap iteration: ", i, "/", bootstrap_num)
    }
    
    indices <- sample(1:nrow(data), replace = TRUE)
    data_boot <- data[indices, ]
    
    suffStat <- list(C = cor(data_boot, use = "pairwise.complete.obs"), 
                     n = nrow(data_boot))
    
    fci_result <- fci(suffStat,
                      indepTest = gaussCItest,
                      alpha = alpha,
                      labels = colnames(data_boot),
                      verbose = FALSE) 
    
    adj_matrix <- fci_result@amat
    
    ### Iterate over all node pairs (upper triangle) to classify edges
    for (a in 1:(n_nodes - 1)) {
      for (b in (a + 1):n_nodes) {
        
        val_ab <- adj_matrix[a, b] # Edge mark at col (b)
        val_ba <- adj_matrix[b, a] # Edge mark at row (a)
        
        # --- 1. Check for Skeleton (ANY edge) ---
        if (val_ab != 0 || val_ba != 0) {
          skeleton_matrix[a, b] <- skeleton_matrix[a, b] + 1
          skeleton_matrix[b, a] <- skeleton_matrix[b, a] + 1 # Make it symmetric
        }
        
        # --- 2. Check for Ancestor ---
        # a --> b or a o-> b
        if (val_ab == 2 && (val_ba == 3 || val_ba == 1)) {
          ancestor_matrix[a, b] <- ancestor_matrix[a, b] + 1
        }
        # b --> a or b o-> a
        if (val_ba == 2 && (val_ab == 3 || val_ab == 1)) {
          ancestor_matrix[b, a] <- ancestor_matrix[b, a] + 1
        }
        
        # --- 3. Check for Confounded ---
        # a <-> b
        if (val_ab == 2 && val_ba == 2) {
          confounded_matrix[a, b] <- confounded_matrix[a, b] + 1
          confounded_matrix[b, a] <- confounded_matrix[b, a] + 1 # Symmetric
        }
        
        # --- 4. Check for Circle ---
        # a o--o b
        if (val_ab == 1 && val_ba == 1) {
          circle_matrix[a, b] <- circle_matrix[a, b] + 1
          circle_matrix[b, a] <- circle_matrix[b, a] + 1 # Symmetric
        }
      }
    }
  }
  
  ### Calculate percentage matrices
  perc_skeleton <- skeleton_matrix / bootstrap_num * 100
  perc_ancestor <- ancestor_matrix / bootstrap_num * 100
  perc_confounded <- confounded_matrix / bootstrap_num * 100
  perc_circle <- circle_matrix / bootstrap_num * 100
  
  ### Return a list of all matrices
  return(list(
    skeleton = perc_skeleton,
    ancestor = perc_ancestor,
    confounded = perc_confounded,
    circle = perc_circle
  ))
}
```

summarize edge types

```{r summarize edge types}
summarize_edge_types <- function(pag_results_list, threshold = 75) {
  stable_edges <- edge_melt_symmetric(pag_results_list$skeleton) |>
    rename(skeleton_perc = value) |>
    filter(skeleton_perc > threshold)
  
  if (nrow(stable_edges) == 0) {
    return(stable_edges)
  }
  
  ancestor_mat <- pag_results_list$ancestor
  confounded_mat <- pag_results_list$confounded
  circle_mat <- pag_results_list$circle
  
  summary_df <- stable_edges |>
    rowwise() |>
    mutate(
      # For symmetric matrices
      confounded_perc = confounded_mat[as.character(Var1), as.character(Var2)],
      circle_perc = circle_mat[as.character(Var1), as.character(Var2)],
      
      # For the directional ancestor matrix
      ancestor_A_to_B_perc = ancestor_mat[as.character(Var1), as.character(Var2)],
      ancestor_B_to_A_perc = ancestor_mat[as.character(Var2), as.character(Var1)]
    ) |>
    ungroup() |>
    arrange(desc(skeleton_perc)) 
    
  return(summary_df)
}
```

Edge melt

```{r}
### Helper 1: Symmetric Edge Melter 
edge_melt_symmetric <- function(adj_matrix){
   ### get upper triangle of the matrix (excluding diagonal)
   diag_adj_matrix <- adj_matrix
   diag_adj_matrix[lower.tri(diag_adj_matrix, diag = TRUE)] <- NA
 
   ### melt the matrix into long format and arrange it by value
   melted_adj_data <- as.data.frame(as.table(diag_adj_matrix)) |>
      na.omit() |>
      rename(Var1 = Var1, Var2 = Var2, value = Freq) |>
      arrange(desc(value))
 
   return(melted_adj_data)
}
```

Visualization  

```{r}
### Helper 2: Visualization 
adj_visualization <- function(adj_matrix, alpha){
 
   ### melt correlation matrix
   adj_df <- as.data.frame(as.table(adj_matrix))
   colnames(adj_df) <- c("Var1", "Var2", "value")
  
   ### reverse factor level in Var2 in melted data
   adj_df$Var2 <- factor(adj_df$Var2, levels = rev(levels(factor(adj_df$Var2))))
 
   ### name plot title
   title = paste("Heatmap of adjacency percentage with alpha", alpha)
 
   ### using ggplot to get heatmap
   ggplot(adj_df, aes(Var1, Var2, fill = value)) +
      geom_tile() +
      scale_fill_gradient2(low = "white",  
                                      high = "red",
                                      limit = c(0,100),  
                                      space = "Lab") +
      scale_x_discrete(position = "top") +  
      theme_minimal() +
      theme(axis.text.x = element_text(angle = 45, hjust = 0, vjust = 0),
               plot.title = element_text(hjust = 0.5, face = "bold", size = 14),) +
      labs(title = title, x = "", y = "")+
      coord_fixed()
}
```

bootstrap helper 

```{r bootstrap pag}
multi_boot_pag <- function(data, bootstrap_num = 500, threshold = 75, seed = 1) {
  
  # get df name
  data_name <- deparse(substitute(data))
  
  alphas <- c(0.01, 0.05, 0.1)
  
  # list to store results
  all_results <- list()
  
  for (current_alpha in alphas) {
    message(paste0("\n--- Running ", data_name, " bootstrap for alpha = ", current_alpha, " ---"))
    
    set.seed(seed) 
    
    # run bootstrap
    run_time <- system.time(
      pag_results_list <- bootstrap_pag_edges(
        data = data, 
        bootstrap_num = bootstrap_num, 
        alpha = current_alpha
      )
    )
    
    print(run_time)
    
    # get summary edge list
    edge_summary_table <- summarize_edge_types(pag_results_list, threshold = threshold) 
    
    print(head(edge_summary_table)) 
    
    # Define Filenames (Using the data_name variable)
    base_filename <- paste0(data_name, "_alpha", current_alpha)
    png_name <- paste0("fci_edge_summary_", base_filename, ".png")
    csv_name <- paste0("fci_stable_edge_summary_", base_filename, ".csv")
    pdf_name <- paste0("fci_heatmap_", base_filename, ".pdf")
    
    # save edge summary table as PNG
    if (nrow(edge_summary_table) > 0) {
      table_plot <- gridExtra::tableGrob(edge_summary_table, rows = NULL)
      ggsave(png_name, plot = table_plot, width = 12, height = 10, dpi = 300)
    }
    
    # save as CSV 
    write.csv(edge_summary_table, csv_name, row.names = FALSE)
    
    # save the heatmap PDF
    skeleton_heatmap <- adj_visualization(
      adj_matrix = pag_results_list$skeleton, 
      alpha = current_alpha
    )
    
    pdf(pdf_name, width = 10, height = 9)
    print(skeleton_heatmap)
    dev.off()
    
    # store in list
    all_results[[paste0("alpha_", current_alpha)]] <- list(
      summary_table = edge_summary_table,
      pag_results = pag_results_list,
      plot = skeleton_heatmap
    )
  }
  
  return(all_results)
}

multi_boot_pag(male_df)
multi_boot_pag(female_df)
multi_boot_pag(diabetes_no_df)
multi_boot_pag(diabetes_yes_df)
multi_boot_pag(diabetes_yes_maybe_df)
multi_boot_pag(kidney_no_df)
multi_boot_pag(kidney_yes_df)
multi_boot_pag(kidney_yes_maybe_df)
```

